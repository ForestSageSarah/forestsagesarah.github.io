<!-- XIVAPI Tooltip Integration -->
<!-- Include in post layout via script_includes -->
<script>
/**
 * XIVAPI Tooltip System
 * Fetches and displays FFXIV item tooltips from XIVAPI v2
 * Includes localStorage caching and FFXIV-authentic styling
 */
(function() {
  'use strict';
  
  const CONFIG = {
    apiBase: 'https://v2.xivapi.com',
    cacheDuration: 7 * 24 * 60 * 60 * 1000, // 7 days in milliseconds
    tooltipDelay: 200, // ms delay before showing tooltip
    language: 'en'
  };
  
  let tooltipElement = null;
  let currentHoverItem = null;
  let showTooltipTimeout = null;
  
  // Initialize on DOM ready
  if (document.readyState === 'loading') {
    document.addEventListener('DOMContentLoaded', init);
  } else {
    init();
  }
  
  function init() {
    createTooltipElement();
    attachEventListeners();
    console.log('[XIVAPI] Tooltip system initialized');
  }
  
  function createTooltipElement() {
    tooltipElement = document.createElement('div');
    tooltipElement.className = 'xivapi-tooltip';
    tooltipElement.style.display = 'none';
    document.body.appendChild(tooltipElement);
  }
  
  function attachEventListeners() {
    const items = document.querySelectorAll('[data-xivapi-item]');
    
    items.forEach(item => {
      // Mouse enter - start delay timer
      item.addEventListener('mouseenter', function(e) {
        currentHoverItem = this;
        const itemId = this.dataset.xivapiItem;
        
        showTooltipTimeout = setTimeout(() => {
          showTooltip(itemId, e);
        }, CONFIG.tooltipDelay);
      });
      
      // Mouse move - update tooltip position
      item.addEventListener('mousemove', function(e) {
        if (tooltipElement.style.display === 'block') {
          positionTooltip(e);
        }
      });
      
      // Mouse leave - hide tooltip
      item.addEventListener('mouseleave', function() {
        clearTimeout(showTooltipTimeout);
        currentHoverItem = null;
        hideTooltip();
      });
    });
    
    console.log(`[XIVAPI] Attached listeners to ${items.length} items`);
  }
  
  async function showTooltip(itemId, event) {
    if (!currentHoverItem) return; // User already moved away
    
    // Show loading state
    tooltipElement.innerHTML = '<div class="xivapi-loading">Loading...</div>';
    tooltipElement.style.display = 'block';
    positionTooltip(event);
    
    try {
      const itemData = await fetchItemData(itemId);
      
      // Check if user still hovering
      if (!currentHoverItem || currentHoverItem.dataset.xivapiItem !== itemId) {
        hideTooltip();
        return;
      }
      
      tooltipElement.innerHTML = buildTooltipHTML(itemData);
      positionTooltip(event);
      
    } catch (error) {
      console.error('[XIVAPI] Failed to fetch item:', itemId, error);
      tooltipElement.innerHTML = '<div class="xivapi-error">Failed to load item data</div>';
    }
  }
  
  function hideTooltip() {
    tooltipElement.style.display = 'none';
  }
  
  async function fetchItemData(itemId) {
    // Check localStorage cache first
    const cached = getCachedItem(itemId);
    if (cached) {
      console.log(`[XIVAPI] Cache hit for item ${itemId}`);
      return cached;
    }
    
    // Fetch from API
    console.log(`[XIVAPI] Fetching item ${itemId} from API`);
    const url = `${CONFIG.apiBase}/item/${itemId}?language=${CONFIG.language}`;
    
    const response = await fetch(url);
    
    if (!response.ok) {
      throw new Error(`HTTP ${response.status}: ${response.statusText}`);
    }
    
    const data = await response.json();
    
    // Cache the result
    cacheItem(itemId, data);
    
    return data;
  }
  
  function getCachedItem(itemId) {
    try {
      const cached = localStorage.getItem(`xivapi_item_${itemId}`);
      if (!cached) return null;
      
      const { data, timestamp } = JSON.parse(cached);
      
      // Check if cache is still valid
      if (Date.now() - timestamp < CONFIG.cacheDuration) {
        return data;
      } else {
        // Cache expired, remove it
        localStorage.removeItem(`xivapi_item_${itemId}`);
        return null;
      }
    } catch (error) {
      console.error('[XIVAPI] Cache read error:', error);
      return null;
    }
  }
  
  function cacheItem(itemId, data) {
    try {
      const cacheData = {
        data: data,
        timestamp: Date.now()
      };
      localStorage.setItem(`xivapi_item_${itemId}`, JSON.stringify(cacheData));
    } catch (error) {
      // localStorage might be full or disabled
      console.warn('[XIVAPI] Cache write failed:', error);
    }
  }
  
  function buildTooltipHTML(itemData) {
    const fields = itemData.fields || {};
    const name = fields.Name || 'Unknown Item';
    const description = fields.Description || '';
    const itemLevel = fields.LevelItem || 0;
    const itemUICategory = fields.ItemUICategory?.fields?.Name || '';
    const rarity = fields.Rarity || 1;
    
    // Determine rarity class for coloring
    const rarityClass = getRarityClass(rarity);
    
    let html = '<div class="xivapi-tooltip-inner">';
    
    // Item name with rarity color
    html += `<div class="item-name ${rarityClass}">${escapeHTML(name)}</div>`;
    
    // Item category and level
    if (itemUICategory || itemLevel > 0) {
      html += '<div class="item-meta">';
      if (itemUICategory) {
        html += `<span class="item-category">${escapeHTML(itemUICategory)}</span>`;
      }
      if (itemLevel > 0) {
        html += `<span class="item-level">Item Level ${itemLevel}</span>`;
      }
      html += '</div>';
    }
    
    // Separator
    html += '<div class="item-separator"></div>';
    
    // Description
    if (description) {
      html += `<div class="item-description">${escapeHTML(description)}</div>`;
    }
    
    // Stats (if applicable)
    if (fields.Stats && Object.keys(fields.Stats).length > 0) {
      html += '<div class="item-stats">';
      for (const [stat, value] of Object.entries(fields.Stats)) {
        html += `<div class="stat-row"><span class="stat-name">${escapeHTML(stat)}</span><span class="stat-value">+${value}</span></div>`;
      }
      html += '</div>';
    }
    
    // Additional info (if available)
    if (fields.CanBeHq) {
      html += '<div class="item-hq-indicator">High Quality</div>';
    }
    
    html += '</div>';
    
    return html;
  }
  
  function getRarityClass(rarity) {
    switch(rarity) {
      case 1: return 'rarity-common';
      case 2: return 'rarity-uncommon';
      case 3: return 'rarity-rare';
      case 4: return 'rarity-relic';
      case 7: return 'rarity-aetherial';
      default: return 'rarity-common';
    }
  }
  
  function positionTooltip(event) {
    const tooltip = tooltipElement;
    const mouseX = event.clientX || event.pageX;
    const mouseY = event.clientY || event.pageY;
    
    // Offset from cursor
    const offsetX = 15;
    const offsetY = 15;
    
    // Get viewport dimensions
    const viewportWidth = window.innerWidth;
    const viewportHeight = window.innerHeight;
    
    // Get tooltip dimensions
    const tooltipRect = tooltip.getBoundingClientRect();
    const tooltipWidth = tooltipRect.width;
    const tooltipHeight = tooltipRect.height;
    
    // Calculate position
    let left = mouseX + offsetX;
    let top = mouseY + offsetY;
    
    // Prevent tooltip from going off-screen horizontally
    if (left + tooltipWidth > viewportWidth - 10) {
      left = mouseX - tooltipWidth - offsetX;
    }
    
    // Prevent tooltip from going off-screen vertically
    if (top + tooltipHeight > viewportHeight - 10) {
      top = mouseY - tooltipHeight - offsetY;
    }
    
    // Ensure tooltip doesn't go off left edge
    if (left < 10) {
      left = 10;
    }
    
    // Ensure tooltip doesn't go off top edge
    if (top < 10) {
      top = 10;
    }
    
    tooltip.style.left = left + window.pageXOffset + 'px';
    tooltip.style.top = top + window.pageYOffset + 'px';
  }
  
  function escapeHTML(str) {
    const div = document.createElement('div');
    div.textContent = str;
    return div.innerHTML;
  }
  
})();
</script>

<style>
/* XIVAPI Tooltip Styles - FFXIV Authentic Design */

.xivapi-tooltip {
  position: absolute;
  z-index: 99999;
  
  /* FFXIV tooltip background */
  background: linear-gradient(to bottom, 
    rgba(26, 26, 26, 0.98) 0%, 
    rgba(18, 18, 18, 0.98) 100%);
  
  /* FFXIV border style */
  border: 2px solid #5a5a5a;
  border-radius: 2px;
  box-shadow: 
    0 0 0 1px rgba(0, 0, 0, 0.8),
    0 4px 16px rgba(0, 0, 0, 0.7),
    inset 0 1px 0 rgba(255, 255, 255, 0.1);
  
  padding: 0;
  min-width: 260px;
  max-width: 360px;
  
  font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", "Meiryo", sans-serif;
  font-size: 13px;
  line-height: 1.5;
  color: #d4d4d4;
  
  pointer-events: none;
  user-select: none;
}

.xivapi-tooltip-inner {
  padding: 12px 14px;
}

/* Item name styling */
.item-name {
  font-size: 15px;
  font-weight: 600;
  margin-bottom: 6px;
  text-shadow: 1px 1px 2px rgba(0, 0, 0, 0.8);
}

/* Rarity colors (FFXIV authentic) */
.rarity-common {
  color: #ffffff;
}

.rarity-uncommon {
  color: #61e34b;
}

.rarity-rare {
  color: #4682f4;
}

.rarity-relic {
  color: #d946ef;
}

.rarity-aetherial {
  color: #ff69b4;
}

/* Item metadata (category and level) */
.item-meta {
  display: flex;
  justify-content: space-between;
  align-items: center;
  font-size: 11px;
  color: #999;
  margin-bottom: 8px;
}

.item-category {
  font-style: italic;
}

.item-level {
  color: #aaa;
}

/* Separator line */
.item-separator {
  height: 1px;
  background: linear-gradient(to right, 
    transparent 0%, 
    rgba(90, 90, 90, 0.6) 20%, 
    rgba(90, 90, 90, 0.6) 80%, 
    transparent 100%);
  margin: 8px 0;
}

/* Description */
.item-description {
  color: #c4c4c4;
  line-height: 1.6;
  margin-top: 8px;
  font-size: 12px;
}

/* Stats section */
.item-stats {
  margin-top: 10px;
  padding-top: 8px;
  border-top: 1px solid rgba(90, 90, 90, 0.4);
}

.stat-row {
  display: flex;
  justify-content: space-between;
  padding: 3px 0;
  font-size: 12px;
}

.stat-name {
  color: #b8b8b8;
}

.stat-value {
  color: #7ed321;
  font-weight: 600;
}

/* HQ indicator */
.item-hq-indicator {
  margin-top: 8px;
  padding: 4px 8px;
  background: rgba(255, 215, 0, 0.15);
  border: 1px solid rgba(255, 215, 0, 0.3);
  border-radius: 2px;
  color: #ffd700;
  font-size: 11px;
  text-align: center;
  font-weight: 600;
}

/* Loading and error states */
.xivapi-loading,
.xivapi-error {
  padding: 12px 14px;
  text-align: center;
  font-size: 12px;
}

.xivapi-loading {
  color: #999;
}

.xivapi-error {
  color: #ff6b6b;
}

/* Item links in content */
[data-xivapi-item] {
  color: #66ccff;
  cursor: help;
  text-decoration: underline;
  text-decoration-style: dotted;
  text-decoration-color: rgba(102, 204, 255, 0.4);
  transition: color 0.2s ease;
}

[data-xivapi-item]:hover {
  color: #88ddff;
  text-decoration-color: rgba(136, 221, 255, 0.6);
}

/* Mobile responsive adjustments */
@media (max-width: 768px) {
  .xivapi-tooltip {
    max-width: 90vw;
    font-size: 12px;
  }
  
  .item-name {
    font-size: 14px;
  }
  
  .item-meta {
    font-size: 10px;
  }
}

/* Dark mode compatibility */
@media (prefers-color-scheme: light) {
  .xivapi-tooltip {
    background: linear-gradient(to bottom, 
      rgba(245, 245, 245, 0.98) 0%, 
      rgba(235, 235, 235, 0.98) 100%);
    border-color: #ccc;
    color: #333;
  }
  
  .item-description {
    color: #555;
  }
  
  .item-separator {
    background: linear-gradient(to right, 
      transparent 0%, 
      rgba(180, 180, 180, 0.6) 20%, 
      rgba(180, 180, 180, 0.6) 80%, 
      transparent 100%);
  }
  
  .stat-name {
    color: #666;
  }
}
</style>
